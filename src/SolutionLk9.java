/*Найти минимум в отсортированном массиве с поворотом с уникальными элементами
Предположим, что массив длины n, отсортированный в порядке возрастания, вращается между 1и nраз.
Например, массив nums = [0,1,2,4,5,6,7]может стать следующим:

[4,5,6,7,0,1,2]если он был повернут 4раз.
[0,1,2,4,5,6,7]если он был повернут 7раз.
Обратите внимание, что поворот массива [a[0], a[1], a[2], ..., a[n-1]]1 раз приводит к
массиву [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Учитывая отсортированный повернутый массив nums уникальных элементов, вернуть минимальный элемент этого массива.

Вы должны написать алгоритм, который работает в O(log n) time.
*/
class SolutionLk9 {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int start = 0;
        int end = nums.length - 1;

        while(start < end) {
            int mid = start + (end - start)/2;

            if (nums[mid] > nums[end]) {
                start = mid + 1;
            } else end = mid;
        }
        return nums[start];
    }
}
